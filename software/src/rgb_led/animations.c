#include "animations.h"

static uint16_t phases[NUM_LEDS];

static const unsigned char sintable[] = {
	0x80, 0x83, 0x86, 0x89, 0x8c, 0x8f, 0x92, 0x95, 0x99, 0x9c, 0x9f, 0xa2, 0xa5, 0xa8, 0xab, 0xad,
	0xb0, 0xb3, 0xb6, 0xb9, 0xbc, 0xbe, 0xc1, 0xc4, 0xc6, 0xc9, 0xcb, 0xce, 0xd0, 0xd3, 0xd5, 0xd7,
	0xda, 0xdc, 0xde, 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xe9, 0xeb, 0xed, 0xee, 0xf0, 0xf1, 0xf3, 0xf4,
	0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfc, 0xfd, 0xfe, 0xfe, 0xfe, 0xff, 0xff, 0xff,
	0xff, 0xff, 0xff, 0xff, 0xfe, 0xfe, 0xfe, 0xfd, 0xfc, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8, 0xf7, 0xf6,
	0xf5, 0xf4, 0xf3, 0xf1, 0xf0, 0xee, 0xed, 0xeb, 0xe9, 0xe8, 0xe6, 0xe4, 0xe2, 0xe0, 0xde, 0xdc,
	0xda, 0xd7, 0xd5, 0xd3, 0xd0, 0xce, 0xcb, 0xc9, 0xc6, 0xc4, 0xc1, 0xbe, 0xbc, 0xb9, 0xb6, 0xb3,
	0xb0, 0xad, 0xab, 0xa8, 0xa5, 0xa2, 0x9f, 0x9c, 0x99, 0x95, 0x92, 0x8f, 0x8c, 0x89, 0x86, 0x83,
	0x80, 0x7d, 0x79, 0x76, 0x73, 0x70, 0x6d, 0x6a, 0x67, 0x64, 0x61, 0x5e, 0x5b, 0x58, 0x55, 0x52,
	0x4f, 0x4c, 0x49, 0x47, 0x44, 0x41, 0x3e, 0x3c, 0x39, 0x36, 0x34, 0x31, 0x2f, 0x2d, 0x2a, 0x28,
	0x26, 0x24, 0x21, 0x1f, 0x1d, 0x1b, 0x1a, 0x18, 0x16, 0x14, 0x13, 0x11, 0x10, 0x0e, 0x0d, 0x0b,
	0x0a, 0x09, 0x08, 0x07, 0x06, 0x05, 0x04, 0x04, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x02, 0x03, 0x04, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
	0x0a, 0x0b, 0x0d, 0x0e, 0x10, 0x11, 0x13, 0x14, 0x16, 0x18, 0x1a, 0x1b, 0x1d, 0x1f, 0x21, 0x24,
	0x26, 0x28, 0x2a, 0x2d, 0x2f, 0x31, 0x34, 0x36, 0x39, 0x3c, 0x3e, 0x41, 0x44, 0x47, 0x49, 0x4c,
	0x4f, 0x52, 0x55, 0x58, 0x5b, 0x5e, 0x61, 0x64, 0x67, 0x6a, 0x6d, 0x70, 0x73, 0x76, 0x79, 0x7d,
};

// shortened to 24 to save binary space since that's all the LEDs I have.
static const unsigned char rands[] = {
	0x67, 0xc6, 0x69, 0x73, 0x51, 0xff, 0x4a, 0xec, 0x29, 0xcd, 0xba, 0xab, 0xf2, 0xfb, 0xe3, 0x46,
	0x7c, 0xc2, 0x54, 0xf8, 0x1b, 0xe8, 0xe7, 0x8d,
};

static uint8_t TwinkleBase(uint32_t ledno)
{
	phases[ledno] += (uint16_t)(rands[ledno & 0xff] + 0x0f) << 3;
	uint8_t index = (uint8_t)(phases[ledno] >> 8);
	return sintable[index];
}

uint32_t ChaseSequence(const uint8_t *seq, uint16_t seq_len, uint32_t ledno, uint32_t frame, uint8_t brightness) {
	uint32_t index = ((frame + ledno) * BYTES_PER_LED) % seq_len;
	uint32_t green = seq[index] >> brightness;
	uint32_t red = seq[index + 1] >> brightness;
	uint32_t blue = seq[index + 2] >> brightness;
	return (green << 24) | (red << 16) | (blue << 8);

}

static const uint8_t rainbow[] = {
	0x80, 0x00, 0x00, 0x80, 0x20, 0x00, 0x80, 0x40, 0x00, 0x80, 0x60, 0x00,
	0x80, 0x80, 0x00, 0x60, 0x80, 0x00, 0x40, 0x80, 0x00, 0x20, 0x80, 0x00,
	0x00, 0x80, 0x00, 0x00, 0x80, 0x20, 0x00, 0x80, 0x40, 0x00, 0x80, 0x60,
	0x00, 0x80, 0x80, 0x00, 0x60, 0x80, 0x00, 0x40, 0x80, 0x00, 0x20, 0x80,
	0x00, 0x00, 0x80, 0x20, 0x00, 0x80, 0x40, 0x00, 0x80, 0x60, 0x00, 0x80,
	0x80, 0x00, 0x80, 0x80, 0x00, 0x60, 0x80, 0x00, 0x40, 0x80, 0x00, 0x20,
};

uint32_t GetLEDRainbow(uint32_t ledno, uint32_t frame, uint8_t brightness) {
	return ChaseSequence(rainbow, sizeof(rainbow), ledno, frame, brightness);
}

uint32_t GetLEDShuffleOn(uint32_t ledno, uint32_t frame, uint8_t brightness) {
	const uint8_t on[] = {0xff, 0x00, 0x00};
	return ChaseSequence(on, sizeof(on), ledno, frame, brightness);
}

uint32_t GetLEDShuffleOff(uint32_t ledno, uint32_t frame, uint8_t brightness) {
	const uint8_t off[] = {0x00, 0xff, 0x00};
	return ChaseSequence(off, sizeof(off), ledno, frame, brightness);
}

uint32_t GetLEDTwinkleIce(uint32_t ledno, uint32_t frame, uint8_t brightness)
{
	(void)frame;
	uint8_t rsbase = TwinkleBase(ledno);
	uint32_t twinkle = rsbase >> 1;
	uint32_t green = 0x7f >> brightness;
	uint32_t red = twinkle >> brightness;
	uint32_t blue = 0x7f >> brightness;
	return (green << 24) | (red << 16) | (blue << 8);
}

uint32_t GetLEDTwinkleRedGreen(uint32_t ledno, uint32_t frame, uint8_t brightness)
{
	(void)frame;
	uint8_t rsbase = TwinkleBase(ledno);
	uint32_t red = (rsbase >> 1) >> brightness;
	uint32_t green = ((0xff - rsbase) >> 1) >> brightness;
	return (green << 24) | (red << 16);
}

typedef struct {
	uint8_t active;
	uint8_t head;
	uint8_t direction;
	uint8_t fade;
} StarState;

static uint8_t Hash8(uint32_t value)
{
	value ^= value >> 7;
	value ^= value << 9;
	value ^= value >> 13;
	return (uint8_t)value;
}

static void UpdateStar(uint8_t star_index, uint32_t frame, StarState * state)
{
	uint32_t cycle_len = NUM_LEDS + (star_index ? 11U : 7U);
	uint32_t active_len = NUM_LEDS / 2U;
	uint32_t cycle_index = frame / cycle_len;
	uint32_t phase = frame % cycle_len;
	uint8_t hash = Hash8(cycle_index + (uint32_t)(star_index * 53U));

	state->direction = star_index ? 0U : 1U;

	if ((hash & 0x3U) == 0U) {
		state->active = 0U;
		return;
	}

	uint8_t start_offset = (uint8_t)(hash % (cycle_len - active_len + 1U));
	if (phase < start_offset || phase >= (uint32_t)start_offset + active_len) {
		state->active = 0U;
		return;
	}

	uint32_t travel = phase - start_offset;
	uint8_t start_pos = Hash8((cycle_index * 11U) + (uint32_t)(star_index * 97U)) % NUM_LEDS;

	if (state->direction) {
		state->head = (uint8_t)((start_pos + travel) % NUM_LEDS);
	} else {
		state->head = (uint8_t)((start_pos + NUM_LEDS - travel) % NUM_LEDS);
	}

	if (active_len > 1U) {
		uint8_t linear = (uint8_t)(((active_len - 1U - travel) * 255U) / (active_len - 1U));
		uint16_t inv = 255U - linear;
		state->fade = (uint8_t)(255U - ((inv * inv) / 255U));
	} else {
		state->fade = 0U;
	}
	state->active = 1U;
}

uint32_t GetLEDShootingStar(uint32_t ledno, uint32_t frame, uint8_t brightness)
{
	static const uint8_t trail[] = { 0xff, 0xb0, 0x70, 0x40, 0x20 };
	static uint32_t last_frame = 0xffffffffU;
	static StarState stars[2];
	uint16_t intensity = 0;

	if (frame != last_frame) {
		UpdateStar(0U, frame, &stars[0]);
		UpdateStar(1U, frame, &stars[1]);
		last_frame = frame;
	}

	for (uint8_t i = 0; i < 2U; i++) {
		if (!stars[i].active) {
			continue;
		}

		uint32_t dist = stars[i].direction
			? (stars[i].head + NUM_LEDS - ledno) % NUM_LEDS
			: (ledno + NUM_LEDS - stars[i].head) % NUM_LEDS;

		if (dist < sizeof(trail)) {
			uint16_t level = trail[dist];
			level = (level * stars[i].fade) / 255U;
			if (level > intensity) {
				intensity = level;
			}
		}
	}

	if (!intensity) {
		return 0;
	}

	uint16_t red = intensity;
	uint16_t green = intensity;
	uint16_t blue = intensity;

	red >>= brightness;
	green >>= brightness;
	blue >>= brightness;
	return ((uint32_t)green << 24) | ((uint32_t)red << 16) | ((uint32_t)blue << 8);
}
